# Story 2.6: Implement CAG Manager Coordinator

**Epic**: Epic 2 - CAG System Implementation
**Story ID**: 2.6
**Priority**: High
**Estimated Effort**: 2-3 days
**Dependencies**: Story 2.5 (CAG Inference Engine)

---

## Status

**Draft**

---

## Story

**As a** developer,
**I want** to implement the CAG Manager as the main coordinator for the CAG system,
**so that** all CAG components are integrated and provide a unified interface for bot integration.

---

## Acceptance Criteria

1. File created: cag/cag_manager.rb
2. CAGManager class integrates all CAG components (KnowledgeLoader, ContextManager, CacheManager, InferenceEngine)
3. Unified interface provides simple query method for bot integration
4. Cache lifecycle management implemented (precompute, load, refresh, invalidate)
5. Configuration management handles all CAG settings
6. Error handling and graceful degradation implemented
7. Integration tests verify all components work together correctly
8. All tests pass in Nix development environment

---

## Integration Verification

- **IV1**: Verify CAGManager integrates seamlessly with existing bot_manager.rb
- **IV2**: Verify configuration compatible with existing bot XML configuration structure
- **IV3**: Verify CAGManager doesn't interfere with existing RAG system operation

---

## Tasks / Subtasks

### Phase 1: CAGManager Core Implementation (AC: 1, 2)

- [ ] **Task 1.1: Create CAGManager Class Structure**
  - [ ] Create cag/cag_manager.rb file
  - [ ] Define CAGManager class with initialization method
  - [ ] Set up configuration parameter handling
  - [ ] Initialize component instance variables
  - [ ] Add logging setup with Print utility

- [ ] **Task 1.2: Integrate CAG Components**
  - [ ] Integrate KnowledgeLoader (from Story 2.2)
  - [ ] Integrate ContextManager (from Story 2.3)
  - [ ] Integrate CacheManager (from Story 2.4)
  - [ ] Integrate InferenceEngine (from Story 2.5)
  - [ ] Implement component lifecycle coordination
  - [ ] Handle component initialization errors

- [ ] **Task 1.3: Configuration Management**
  - [ ] Parse CAG configuration from hash or XML
  - [ ] Validate configuration parameters
  - [ ] Set default values for optional parameters
  - [ ] Pass configuration to component initializers
  - [ ] Document configuration schema

### Phase 2: Unified Query Interface (AC: 3)

- [ ] **Task 2.1: Implement Primary Query Method**
  - [ ] Create query(query_text, options = {}) method
  - [ ] Route query through InferenceEngine
  - [ ] Handle query preprocessing
  - [ ] Format response for bot consumption
  - [ ] Add query logging and metrics

- [ ] **Task 2.2: Add Query Enhancement Features**
  - [ ] Implement context-aware query handling
  - [ ] Support conversation history (multi-turn)
  - [ ] Add metadata to responses (sources, confidence)
  - [ ] Implement query timeout handling
  - [ ] Add performance timing instrumentation

- [ ] **Task 2.3: Error Handling and Fallbacks**
  - [ ] Handle cache miss scenarios
  - [ ] Implement graceful degradation
  - [ ] Provide meaningful error messages
  - [ ] Add fallback to RAG system (if configured)
  - [ ] Log all error conditions appropriately

### Phase 3: Cache Lifecycle Management (AC: 4)

- [ ] **Task 3.1: Cache Precomputation Workflow**
  - [ ] Implement precompute_cache(knowledge_sources) method
  - [ ] Load documents via KnowledgeLoader
  - [ ] Assemble context via ContextManager
  - [ ] Precompute KV cache via CacheManager
  - [ ] Validate cache integrity after precomputation
  - [ ] Log cache precomputation metrics

- [ ] **Task 3.2: Cache Loading Workflow**
  - [ ] Implement load_cache(cache_path) method
  - [ ] Load existing cache via CacheManager
  - [ ] Validate cache version and compatibility
  - [ ] Handle corrupted cache files
  - [ ] Log cache loading metrics

- [ ] **Task 3.3: Cache Refresh and Invalidation**
  - [ ] Implement refresh_cache(knowledge_sources) method
  - [ ] Implement invalidate_cache() method
  - [ ] Support incremental cache updates
  - [ ] Handle cache versioning
  - [ ] Document cache refresh policies

### Phase 4: Configuration and Initialization (AC: 5)

- [ ] **Task 4.1: Configuration Schema Design**
  - [ ] Define CAG configuration parameters
  - [ ] Specify required vs optional parameters
  - [ ] Document configuration examples
  - [ ] Create configuration validation logic
  - [ ] Support multiple configuration formats (hash, XML)

- [ ] **Task 4.2: Component Configuration Passing**
  - [ ] Extract component-specific configurations
  - [ ] Pass configurations to KnowledgeLoader
  - [ ] Pass configurations to ContextManager
  - [ ] Pass configurations to CacheManager
  - [ ] Pass configurations to InferenceEngine

- [ ] **Task 4.3: Runtime Reconfiguration Support**
  - [ ] Allow configuration updates without restart
  - [ ] Implement configuration reload mechanism
  - [ ] Validate new configurations before applying
  - [ ] Handle configuration change impacts on cache

### Phase 5: Error Handling and Resilience (AC: 6)

- [ ] **Task 5.1: Component Failure Handling**
  - [ ] Handle KnowledgeLoader failures
  - [ ] Handle ContextManager failures
  - [ ] Handle CacheManager failures
  - [ ] Handle InferenceEngine failures
  - [ ] Implement circuit breaker pattern for repeated failures

- [ ] **Task 5.2: Graceful Degradation**
  - [ ] Detect unavailable LLM providers
  - [ ] Fallback to RAG system (if configured)
  - [ ] Return informative error messages to bot
  - [ ] Maintain service availability during component issues
  - [ ] Log degradation events

- [ ] **Task 5.3: Resource Management**
  - [ ] Implement memory usage monitoring
  - [ ] Add cache size limits
  - [ ] Handle out-of-memory scenarios
  - [ ] Implement cleanup mechanisms
  - [ ] Add resource usage logging

### Phase 6: Integration Testing (AC: 7, 8)

- [ ] **Task 6.1: Component Integration Tests**
  - [ ] Test KnowledgeLoader integration
  - [ ] Test ContextManager integration
  - [ ] Test CacheManager integration
  - [ ] Test InferenceEngine integration
  - [ ] Test end-to-end query workflow

- [ ] **Task 6.2: Cache Lifecycle Tests**
  - [ ] Test cache precomputation workflow
  - [ ] Test cache loading workflow
  - [ ] Test cache refresh workflow
  - [ ] Test cache invalidation workflow
  - [ ] Test cache versioning

- [ ] **Task 6.3: Configuration Tests**
  - [ ] Test configuration parsing
  - [ ] Test configuration validation
  - [ ] Test default value handling
  - [ ] Test invalid configuration handling
  - [ ] Test configuration reload

- [ ] **Task 6.4: Error Handling Tests**
  - [ ] Test component failure scenarios
  - [ ] Test graceful degradation
  - [ ] Test error message quality
  - [ ] Test fallback mechanisms
  - [ ] Test resource limit handling

- [ ] **Task 6.5: Run Tests in Nix Environment**
  - [ ] Execute all CAGManager tests
  - [ ] Verify all tests pass
  - [ ] Fix any environment-specific issues
  - [ ] Document test execution procedures
  - [ ] Verify tests run offline

### Phase 7: Bot Integration Preparation (IV1, IV2, IV3)

- [ ] **Task 7.1: Bot Manager Integration Interface**
  - [ ] Design bot_manager.rb integration points
  - [ ] Create CAG mode selection logic
  - [ ] Implement CAG query routing from bot
  - [ ] Test integration with existing bot commands
  - [ ] Document bot integration procedures

- [ ] **Task 7.2: Configuration Compatibility**
  - [ ] Ensure CAG configuration compatible with bot XML
  - [ ] Add CAG configuration examples to docs
  - [ ] Test backward compatibility with RAG-only configs
  - [ ] Verify optional CAG configuration
  - [ ] Document configuration migration

- [ ] **Task 7.3: RAG System Coexistence**
  - [ ] Verify RAG system remains functional
  - [ ] Test CAG/RAG hybrid mode
  - [ ] Implement intelligent routing logic
  - [ ] Verify no performance degradation to RAG
  - [ ] Document system selection criteria

---

## Dev Notes

### CAGManager Responsibilities

**Main Coordinator Role**:
- Integrates all CAG components into cohesive system
- Provides simple, unified interface for bot integration
- Manages component lifecycle and coordination
- Handles configuration and initialization
- Implements error handling and resilience
- [Source: docs/stories/epic-2-cag-system-implementation.md#64]

**Component Integration**:
1. **KnowledgeLoader**: Loads and preprocesses knowledge base documents
2. **ContextManager**: Manages document assembly and context optimization
3. **CacheManager**: Handles KV cache precomputation and storage
4. **InferenceEngine**: Generates responses using cached context
[Source: docs/stories/epic-2-cag-system-implementation.md#42-47]

### CAGManager Interface Design

**Primary Methods**:

```ruby
class CAGManager
  # Initialize CAG system with configuration
  def initialize(config = {})
    @config = validate_and_default_config(config)
    @knowledge_loader = KnowledgeLoader.new(@config[:knowledge_loader])
    @context_manager = ContextManager.new(@config[:context_manager])
    @cache_manager = CacheManager.new(@config[:cache_manager])
    @inference_engine = InferenceEngine.new(@config[:inference_engine])
  end

  # Main query interface for bot integration
  def query(query_text, options = {})
    # Route through inference engine with cached context
  end

  # Cache lifecycle management
  def precompute_cache(knowledge_sources)
    # Load documents, assemble context, precompute KV cache
  end

  def load_cache(cache_path)
    # Load existing cache from storage
  end

  def refresh_cache(knowledge_sources = nil)
    # Update cache with new/modified documents
  end

  def invalidate_cache
    # Clear cache, force recomputation
  end

  # Status and health checks
  def ready?
    # Check if CAG system is ready for queries
  end

  def cache_status
    # Return cache metadata and statistics
  end
end
```

### Configuration Schema

**CAG Configuration Structure**:

```ruby
cag_config = {
  # Knowledge loader configuration
  knowledge_loader: {
    sources: ['knowledge_bases/sources/mitre_attack', ...],
    chunk_size: 512,
    overlap: 50
  },

  # Context manager configuration
  context_manager: {
    max_context_tokens: 32000,
    prioritization: 'relevance',  # or 'recency', 'source'
    compression: true
  },

  # Cache manager configuration
  cache_manager: {
    storage_path: 'cag/cache',
    compression: true,
    version: '1.0'
  },

  # Inference engine configuration
  inference_engine: {
    llm_provider: 'ollama',
    model: 'llama3.2-vision:90b',
    temperature: 0.7
  },

  # Fallback configuration
  fallback: {
    enabled: true,
    rag_manager: @rag_manager  # Optional RAG fallback
  }
}
```

### Integration with Bot Manager

**Bot Manager Integration Pattern**:

```ruby
# In bot_manager.rb or equivalent
class BotManager
  def initialize(config)
    # Existing initialization...

    # Add CAG manager if configured
    if config[:cag_enabled]
      @cag_manager = CAGManager.new(config[:cag])
      @cag_manager.load_cache(config[:cag][:cache_path])
    end
  end

  def handle_query(user, query)
    # Route to CAG or RAG based on configuration
    if @cag_enabled && @cag_manager.ready?
      response = @cag_manager.query(query, user: user)
    else
      response = @rag_manager.query(query, user: user)
    end

    send_to_irc(user, response)
  end
end
```

### Cache Lifecycle Workflow

**Precomputation Workflow**:
1. Load all knowledge base documents via KnowledgeLoader
2. Preprocess and chunk documents
3. Assemble full context via ContextManager
4. Optimize context for model's context window
5. Precompute KV cache via CacheManager
6. Store cache to disk with metadata
7. Log metrics (time, memory, cache size)

**Loading Workflow**:
1. Check cache file existence and validity
2. Load cache metadata and validate version
3. Load KV cache into memory via CacheManager
4. Validate cache integrity
5. Mark system as ready for queries
6. Log cache statistics

**Refresh Workflow**:
1. Detect modified/new documents in knowledge base
2. Load incremental changes via KnowledgeLoader
3. Update context via ContextManager
4. Incrementally update KV cache (if supported)
5. Or: Full cache recomputation (if incremental not supported)
6. Update cache version and metadata
7. Log refresh metrics

### Error Handling Strategy

**Component Failure Handling**:
- KnowledgeLoader fails: Log error, cannot proceed with cache operations
- ContextManager fails: Log error, fallback to smaller context or RAG
- CacheManager fails: Log error, fallback to RAG system
- InferenceEngine fails: Log error, return error message to bot

**Graceful Degradation Pattern**:
```ruby
def query(query_text, options = {})
  return fallback_query(query_text, options) unless @cache_manager.cache_loaded?

  begin
    response = @inference_engine.generate(query_text, @cache_manager.cache)
    return response
  rescue InferenceError => e
    Print.err "CAG inference failed: #{e.message}"
    return fallback_query(query_text, options) if @config[:fallback][:enabled]
    raise
  end
end

def fallback_query(query_text, options)
  if @rag_manager
    Print.info "Falling back to RAG system"
    @rag_manager.query(query_text, options)
  else
    raise CAGError, "CAG unavailable and no fallback configured"
  end
end
```

### Performance Considerations

**Target Metrics** (from Epic 2):
- Cache precomputation time: ≤5 minutes for typical knowledge base
- Cache loading time: ≤30 seconds from stored cache
- Query latency: ≤2 seconds (target: 50-80% improvement over RAG)
- Memory usage: ≤6GB for typical knowledge bases with CAG
[Source: docs/stories/epic-2-cag-system-implementation.md#220-225]

**Optimization Strategies**:
- Lazy component initialization (only create when needed)
- Cache validation shortcuts (checksum verification)
- Efficient configuration parsing
- Minimal query preprocessing overhead
- Performance instrumentation for bottleneck identification

### Testing Strategy

**Integration Test Scenarios**:
1. Full cache precomputation and query workflow
2. Cache save and load across restarts
3. Incremental cache refresh
4. Component failure recovery
5. Configuration validation and defaults
6. Bot integration with CAG queries
7. CAG/RAG hybrid mode switching
8. Offline operation verification

**Test Data**:
- Use test knowledge base (subset of MITRE ATT&CK, sample man pages)
- Sample cybersecurity queries
- Invalid configuration examples
- Corrupted cache files

### Existing Patterns to Follow

**Manager Pattern** (from RAG system):
```ruby
# rag/rag_manager.rb provides reference for:
# - Configuration handling
# - Component coordination
# - Query interface design
# - Error handling patterns
```
[Source: Existing codebase - rag/rag_manager.rb]

**Bot Integration Pattern**:
```ruby
# bot_manager.rb or bot_framework.rb shows:
# - XML configuration parsing
# - LLM provider integration
# - IRC response handling
```

### Offline Operation Requirements

**CRITICAL**: CAG system must work offline
- Use Ollama for local LLM inference
- Pre-computed caches stored locally
- No external API calls required
- Knowledge bases loaded from local files
- Cache storage on local filesystem
[Source: docs/prd.md#2.3 CR8: Offline Operation]

### Documentation Requirements

**Code Documentation**:
- Inline comments for complex coordination logic
- Method-level documentation for public API
- Configuration schema documentation
- Error message documentation

**External Documentation**:
- Update docs/development/CAG_IMPLEMENTATION_SUMMARY.md (to be created in Story 2.9)
- Add CAG configuration examples
- Document cache management procedures
- Document bot integration steps

---

## Testing

### Testing Strategy for This Story

**Unit Testing**:
- Test CAGManager initialization with various configurations
- Test configuration validation and defaults
- Test component integration
- Test error handling for component failures

**Integration Testing**:
- Test full query workflow end-to-end
- Test cache lifecycle (precompute, load, refresh, invalidate)
- Test graceful degradation and fallbacks
- Test bot integration interface

**Performance Testing**:
- Measure initialization time
- Measure query latency
- Measure cache operations performance
- Verify memory usage within limits

### Test Execution Commands

```bash
# Run CAGManager integration tests
ruby test/test_cag_manager_integration.rb

# Run with verbose output
ruby test/test_cag_manager_integration.rb --verbose

# Run in Nix environment
nix develop
ruby test/test_cag_manager_integration.rb

# Run all CAG tests (optional)
ruby test/test_cag_comprehensive.rb
```

### Success Criteria

✅ All CAGManager integration tests pass
✅ All components integrated correctly
✅ Unified query interface functional
✅ Cache lifecycle management operational
✅ Configuration management robust
✅ Error handling and graceful degradation working
✅ Tests pass offline in Nix environment
✅ Ready for bot integration

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | v1.0 | Initial story creation for CAG Manager | Story Agent |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_This section will be populated by QA Agent after story completion._

---

**Story prepared by**: Story Agent
**Ready for**: Developer Agent implementation (after Story 2.5 completion)
**Next Story**: 2.7 - Create Comprehensive CAG Test Suite (depends on this story completion)
